#include "Vis.h"

namespace Vis
{

ML_PERSISTENT_IMPL2(Shape,VIS_BASIC_PTAG);

//=====================================================================================//
//                                   Shape::Shape()                                    //
//=====================================================================================//
Shape::Shape()
{
}

//=====================================================================================//
//                                   Shape::Shape()                                    //
//=====================================================================================//
Shape::Shape(const Shape &s)
:	Piece(s)
{
}

//=====================================================================================//
//                                   Shape::Shape()                                    //
//=====================================================================================//
Shape::Shape(Storage::ReadSlot &slot)
:	Piece(slot)
{
}

//=====================================================================================//
//                                   Shape::Shape()                                    //
//=====================================================================================//
Shape::Shape(const std::string &name, Node *parent, const OptionSet &options)
:	Piece(name,parent,options)
{
}

//=====================================================================================//
//                                   Shape::~Shape()                                   //
//=====================================================================================//
Shape::~Shape()
{
}

//=====================================================================================//
//                           bool Shape::isIdentical() const                           //
//=====================================================================================//
bool Shape::isIdentical(const Piece *piece) const
{
	if(piece->rtti_dynamic() != rtti_dynamic()) return false;
	if(piece->getMaterial() != getMaterial()) return false;
	return true;
}

//=====================================================================================//
//                             Piece *Shape::clone() const                             //
//=====================================================================================//
Shape *Shape::clone(Node *newParent, Storage::Repository *rep) const
{
	Shape *copy = rep->construct<Shape>(getName(),newParent,getOptions());
	copy->setMaterial(getMaterial());
	return copy;
}

}