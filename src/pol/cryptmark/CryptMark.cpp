#include "precomp.h"
#include "CryptMark.h"
#include "Mark.h"

namespace SecurityMark
{

/// Строка с ключом и маркером
static const char *g_mark = "\0\xfe\x77\x6a\x2d\xfc\x75\xcb\x34\xa7\x79\xf5\x58 \x3e\xf9\x22\x4d\xcb\x86\x21\x96\x5a\xd9\x6c\x32\x50\xd1\x2c\x31\xd1\x1a\x36\xac\xde\xb9\x44\xfb\xc0\xe5\x85\x27\xaa\x19\x59\xa2\x9a\x67\x55\x36\x80\xf\x8e\x3c\xa2\x50\x14\xe\x3f\x7e\xbc\xbf\x72\x55\x23\x9\x5a\x8d\xef\x86\x78\xae\x58\x23\x58\x26\xe8\xd3\x74\x99\x7e\x80\x55\x78\x99\x47\xfb\xd5\xd3\xe4\x7f\x76\xac\x6b\xf7\x28\x89\x3a\x9a\x55\xfd\x2b\x25\xd9\x46\xe\x7d\x12\x1b\x56\x95\x36\xa5\x12\x92\xea\xcb\x1f\x2d\x10\xb2\x9c\x59\xe0\x84\x9f\x26\x3a\x71\x26\xe6\x3a\xf4\x51\x8e\xe\x58\xce\x5f\x4\x7a\x94\xc5\xe7\xd0\xd4\x7f\x8c\xaa\x2c\xa8\xa8\xb8\x1f\x15\xe4\xcd\xc2\xc9\x34\xe2\xb7\x86\x64\x5e\x5f\x7c\xf4\x95\x4c\x46\x25\x8e\xf5\xcb\x54\x9\xae\x63\x87\xc0\xd7\x3c\x46\xee\x53\xfb\xac\xe\x3c\xa6\xbd\xe5\xd4\xc1\xfa\xc2\xbf\xb7\x33\x5\x70\x7c\x9d\xde\xe2\x71\x24\x57\x88\x88\x2\x95\x86\xa8\x91\x5a\x21\x53\x5d\xcf\x74\x86\x7e\x81\x65\xe0\x25\xa9\xd8\x7\x74\xb0\x23\x48\x93\xf2\xc1\x7d\xa7\xc3\x4a\x34\x26\xaf\xa2\xd\x32\x6\x71\x64\x22\x99\xd4\x30\x1e\xbe\x53\x2b\xc\x9a\x12\x34\x5f\x9f\x4b\xf1\x2f\x53\xfb";

// Конструктор
CryptMark::CryptMark()
{
	decrypt();
}

// Создание singelton'а
const CryptMark* CryptMark::getInstance()
{
	static CryptMark _instance;
	return &_instance;
}

// После вызова этой функции строка - g_mark, будет помещена в файл 
int CryptMark::forceInstantiate()
{
	return reinterpret_cast<int>(g_mark);
}

// Проверка файла на наличие маркировки
bool CryptMark::isMarked() const
{
	// default'ый маркер
	std::string rbuf (Mark::MARK_DEF.c_str(), Mark::MARK_DEF.c_str()+250 );
	
	// текущий маркер
	std::string drbuf(g_mark+13, g_mark+250+13 );

	if(rbuf==drbuf)
		return false;

	return true;
}

// Расшифровка метки
void CryptMark::decrypt()
{
	// Если файл не помечен
	if(!isMarked())
	{
		m_label="";
		m_guid="";
		m_comp="";
		m_time=0;

		return;
	}

	int i=0;

	m_label.resize(Mark::MAX_MARK_LEN);
	for(;i<(Mark::MAX_MARK_LEN-1);i++)
		m_label[i]=g_mark[13+i]^Mark::CRYPT_STR[i];

	int j=i+1;

	m_guid.resize(Mark::MAX_GUID_STR_LEN);
	for(i=0;i<(Mark::MAX_GUID_STR_LEN-1);i++)
		m_guid[i]=g_mark[13+i+j]^Mark::CRYPT_STR[i];

	j+=i+1;

	m_comp.resize(Mark::MAX_COMP_STR_LEN);
	for(i=0;i<(Mark::MAX_COMP_STR_LEN);i++)
		m_comp[i]=g_mark[13+i+j]^Mark::CRYPT_STR[i];

	j+=i+1;

	m_time=*reinterpret_cast<const time_t*>(g_mark+13+j);
}

}